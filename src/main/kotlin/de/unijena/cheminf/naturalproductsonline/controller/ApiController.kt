package de.unijena.cheminf.naturalproductsonline.controller


import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProduct
import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProductRepository
import de.unijena.cheminf.naturalproductsonline.model.AdvancedSearchModel
import de.unijena.cheminf.naturalproductsonline.utils.AtomContainerToUniqueNaturalProductService
import net.minidev.json.JSONObject
import net.sf.jniinchi.INCHI_OPTION
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.fingerprint.PubchemFingerprinter
import org.openscience.cdk.inchi.InChIGeneratorFactory
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.isomorphism.*
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.openscience.cdk.isomorphism.DfPattern
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Slice
import org.springframework.http.MediaType
import org.springframework.http.MediaType.APPLICATION_JSON_VALUE
import org.springframework.web.bind.annotation.*
import java.net.URLDecoder


@RestController
@RequestMapping("/api")
class ApiController(val uniqueNaturalProductRepository: UniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)
    internal var pubchemFingerprinter = PubchemFingerprinter(SilentChemObjectBuilder.getInstance())

    val options = mutableListOf(INCHI_OPTION.SNon, INCHI_OPTION.ChiralFlagOFF, INCHI_OPTION.AuxNone)

    val universalIsomorphismTester = UniversalIsomorphismTester()


    @Autowired
    lateinit var atomContainerToUniqueNaturalProductService: AtomContainerToUniqueNaturalProductService


    /**
     * Advanced structure handling
     */

    @RequestMapping("/search/advanced" )
    @ResponseBody
    fun advancedSearch(@RequestParam("max-hits", required = false) maxHits:String, @RequestBody advancedSearchModel: AdvancedSearchModel): Map<String, Any>{

        println("catched advanced search")
        //println(advancedSearchModel.listOfSearchItems[1])
        return this.doAdvancedSearch(maxHits.toIntOrNull(),advancedSearchModel )

    }

    /**
     *  Exact structure handling
     */
    @RequestMapping("/search/exact-structure")
    fun structureSearchBySmiles(@RequestParam("smiles") smiles: String, @RequestParam("type") type: String): Map<String, Any> {

        if(type=="smi") {
            return this.doExactStructureSearchBySmiles(URLDecoder.decode(smiles.trim(), "UTF-8"))
        }else{
            return this.doExactStructureSearchByInchi(URLDecoder.decode(smiles.trim(), "UTF-8"))
        }
    }


    /**
     *  Substructure handling
     */
    @RequestMapping("/search/substructure")
    fun substructureSearch(@RequestParam("smiles") smiles: String , @RequestParam("type") type: String , @RequestParam("max-hits") maxHits:String): Map<String, Any> {
        return this.doSubstructureSearch(URLDecoder.decode(smiles.trim(), "UTF-8"), type, maxHits.toIntOrNull())
    }


    /**
     * Simple (navigation bar) search handling
     */
    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") queryString: String): Map<String, Any> {
        /* switch between simple and simple heuristic search
        * the latter tries to guess the input type that could become harder with more search options
        */
        println(queryString)
        return this.doSimpleSearchWithHeuristic(URLDecoder.decode(queryString.trim(), "UTF-8"))
        // return this.doSimpleSearch(URLDecoder.decode(queryString.trim(), "UTF-8"))
    }


    /**
     *  ************************************************************************************************
     *  Search functions
     */


    fun doAdvancedSearch(maxHits:Int?, advancedSearchModel: AdvancedSearchModel) : Map<String, Any>{

        var maxResults = 1000

        if(maxHits != null ){
            maxResults = maxHits
        }

        val results = this.uniqueNaturalProductRepository.advancedSearchWithCriteria(advancedSearchModel)

        results.shuffle()

        val resultsPart = results.subList(0, minOf(results.size , maxResults))

        resultsPart.sortBy { it.heavy_atom_number }



        return mapOf(
                "originalQuery" to "advanced",
                "count" to resultsPart.size,
                "naturalProducts" to resultsPart
        )

    }






    fun doExactStructureSearchByInchi(smiles: String): Map<String, Any> {

        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val gen = InChIGeneratorFactory.getInstance().getInChIGenerator(queryAC, options)

            var queryInchi =  gen.getInchi()


            val results = this.uniqueNaturalProductRepository.findByInchi(queryInchi)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }

    fun doExactStructureSearchBySmiles(smiles: String) : Map<String, Any>{


        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val querySmiles = smilesGenerator.create(queryAC)


            val results = this.uniqueNaturalProductRepository.findByClean_smiles(querySmiles)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }

    }






    fun doSimpleSearchWithHeuristic(query: String): Map<String, Any> {
        // determine type of input on very basic principles without validation



        var inchiPattern = Regex("^InChI=.*$")
        val inchikeyPattern = Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$")
        val molecularFormulaPattern = Regex("C[0-9]+?H[0-9].+")
        var smilesPattern = Regex("^([^Jj][A-Za-z0-9@+\\-\\[\\]\\(\\)\\\\\\/%=#\$]+)\$")
        val coconutPattern = Regex("^CNP[0-9]+?$")

        var naturalProducts : List<UniqueNaturalProduct>
        val determinedInputType : String


        if(smilesPattern.containsMatchIn(query)){

            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(query)
            val querySmiles = this.smilesGenerator.create(queryAC)
            determinedInputType = "SMILES"

            naturalProducts =  this.uniqueNaturalProductRepository.findByClean_smiles(querySmiles)
            if(naturalProducts.isEmpty()) {
                naturalProducts = this.uniqueNaturalProductRepository.findBySmiles(querySmiles)
            }

        }
        else if(coconutPattern.containsMatchIn(query)){
            naturalProducts =  this.uniqueNaturalProductRepository.findByCoconut_id(query)
            determinedInputType = "COCONUT ID"
        }
        else if(inchiPattern.containsMatchIn(query)){
            naturalProducts =  this.uniqueNaturalProductRepository.findByInchi(query)
            determinedInputType = "InChi"
        }
        else if(inchikeyPattern.containsMatchIn(query)){
            naturalProducts =  this.uniqueNaturalProductRepository.findByInchikey(query)
            determinedInputType = "InChi Key"
        }
        else if(molecularFormulaPattern.containsMatchIn(query)){
            naturalProducts = this.uniqueNaturalProductRepository.findByMolecular_formula(query)
            determinedInputType = "molecular formula"
        }
        else{
            //try to march by name
            naturalProducts = this.uniqueNaturalProductRepository.findByName(query)

            if(naturalProducts == null || naturalProducts.isEmpty()){
                naturalProducts = this.uniqueNaturalProductRepository.fuzzyNameSearch(query)
            }
            determinedInputType = "name"
        }

        println("returning")




        return mapOf(
                "originalQuery" to query,
                "determinedInputType" to determinedInputType,
                "naturalProducts" to naturalProducts
        )
    }






    fun doSubstructureSearch(smiles: String, type: String, maxHitsSubmitted: Int?): Map<String, Any> {
        println("Entering substructure search")

        println(smiles)

        var maxResults = 1000

        if(maxHitsSubmitted != null ){
            maxResults = maxHitsSubmitted
        }

        val hits = mutableListOf<UniqueNaturalProduct>()
        var counter: Int = 0

        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)

            println(pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet().toByteArray())

            // run $allBitsSet in mongo
            val matchedList = this.uniqueNaturalProductRepository.findAllPubchemBitsSet(pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet().toByteArray())

            //TODO get the exact bitset also?

            println("found molecules with bits set")
            val pattern: Pattern
            // return a list of UNP:
            if(type=="default") {
                // for each UNP - convert to IAC and run the Ullmann
                pattern = Ullmann.findSubstructure(queryAC)
                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        //println(unp.coconut_id)

                        counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }else if(type=="df"){
                pattern = DfPattern.findSubstructure(queryAC)

                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)
                    if (pattern.matches(targetAC)) {
                        hits.add(unp)
                        //println(unp.coconut_id)
                        counter++
                        //if (counter==maxResults) break@loop

                    }
                }


            }else{
                //Vento-Foggia
                pattern = VentoFoggia.findSubstructure(queryAC)
                for(unp in matchedList){ //loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        println(unp.coconut_id)

                        //counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }


            hits.sortBy { it.heavy_atom_number }
            val hitsToReturn = hits.subList(0, maxResults)

            println("ready to return results!")

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to  hitsToReturn.size,
                    "naturalProducts" to hitsToReturn
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }




    fun doSimilaritySearch(smiles: String): Map<String, Any>{

        var count: Int = 0
        var hits = 0



        return mapOf(
                "originalQuery" to smiles,
                "count" to count,
                "naturalProducts" to hits
        )

    }
}