package de.unijena.cheminf.naturalproductsonline.controller


import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProduct
import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProductRepository
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.isomorphism.Ullmann
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Slice
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.net.URLDecoder

@RestController
@RequestMapping("/api")
class ApiController(val uniqueNaturalProductRepository: UniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)

    @RequestMapping("/search/structure")
    fun structureSearchBySmiles(@RequestParam("smiles") smiles: String): Map<String, Any> {
        return this.doStructureSearchBySmiles(URLDecoder.decode(smiles.trim(), "UTF-8"))
    }

    @RequestMapping("/search/substructure")
    fun substructureSearch(@RequestParam("smiles") smiles: String): Map<String, Any> {
        return this.doSubstructureSearch(URLDecoder.decode(smiles.trim(), "UTF-8"))
    }

    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") queryString: String): Map<String, Any> {
        /* switch between simple and simple heuristic search
        * the latter tries to guess the input type that could become harder with more search options
        */
        println(queryString)
        return this.doSimpleSearchWithHeuristic(URLDecoder.decode(queryString.trim(), "UTF-8"))
        // return this.doSimpleSearch(URLDecoder.decode(queryString.trim(), "UTF-8"))
    }

    fun doStructureSearchBySmiles(smiles: String): Map<String, Any> {
        try {
            val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val canonicalSmiles: String = this.smilesGenerator.create(parsedSmiles)

            val results = this.uniqueNaturalProductRepository.findByClean_smiles(canonicalSmiles)

            return mapOf(
                    "originalQuery" to canonicalSmiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }

    fun doSubstructureSearch(smiles: String): Map<String, Any> {
        try {
            val parsedSubstructureSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val pattern = Ullmann.findSubstructure(parsedSubstructureSmiles)

            val hits = mutableListOf<UniqueNaturalProduct>()
            var hitsCount: Int = 0

            // do not fetch all at once since this would have insane memory requirements
            var pageable: Pageable = PageRequest.of(0, 1000)
            var slice: Slice<UniqueNaturalProduct>

            while (true) {
                slice = this.uniqueNaturalProductRepository.findAll(pageable)
                val uniqueNaturalProducts: List<UniqueNaturalProduct> = slice.content

                for (uniqueNaturalProduct in uniqueNaturalProducts) {
                    println(uniqueNaturalProduct.smiles)
                    val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(uniqueNaturalProduct.getSmiles())
                    val match = pattern.match(parsedSmiles);

                    // do not save all hits since this would have insane memory requirements for simple and often reoccurring substructures
                    if (match.isNotEmpty()) {
                        hitsCount++

                        if (hitsCount < 250) {
                            hits.add(uniqueNaturalProduct)
                        }
                    }
                }

                if (!slice.hasNext()) {
                    break
                }

                pageable = slice.nextPageable()
            }

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to hitsCount,
                    "naturalProducts" to hits
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }


    fun doSimpleSearch(query: String): Map<String, Any> {
        val naturalProducts = mutableSetOf<UniqueNaturalProduct>()

        naturalProducts += this.uniqueNaturalProductRepository.findBySmiles(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByClean_smiles(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByInchi(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByInchikey(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByMolecular_formula(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByCoconut_id(query)

        return mapOf(
                "originalQuery" to query,
                "naturalProducts" to naturalProducts
        )
    }

    //TODO add search by name and search by COCONUT id
    fun doSimpleSearchWithHeuristic(query: String): Map<String, Any> {
        // determine type of input on very basic principles without validation

        var queryType = "unknown"


        var inchiPattern = Regex("^InChI=.*$")
        val inchikeyPattern = Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$")
        val molecularFormulaPattern = Regex("C[0-9]+?H[0-9].+")
        //var smilesPattern = Regex("^([^Jj][A-Za-z0-9@+\\-\\[\\]\\(\\)\\\\\\/%=#\$]+)\$")
        val coconutPattern = Regex("^CNP[0-9]+?$")

        var naturalProducts : List<UniqueNaturalProduct>
        val determinedInputType : String


        /*if(smilesPattern.containsMatchIn(query)){
             naturalProducts =  this.uniqueNaturalProductRepository.findBySmiles(query)
             determinedInputType = "SMILES"
        }
        else */
        if(coconutPattern.containsMatchIn(query)){
             naturalProducts =  this.uniqueNaturalProductRepository.findByCoconut_id(query)
             determinedInputType = "COCONUT ID"
        }
        else if(inchiPattern.containsMatchIn(query)){
             naturalProducts =  this.uniqueNaturalProductRepository.findByInchi(query)
             determinedInputType = "InChi"
        }
        else if(inchikeyPattern.containsMatchIn(query)){
             naturalProducts =  this.uniqueNaturalProductRepository.findByInchikey(query)
             determinedInputType = "InChi Key"
        }
        else if(molecularFormulaPattern.containsMatchIn(query)){
            naturalProducts = this.uniqueNaturalProductRepository.findByMolecular_formula(query)
             determinedInputType = "molecular formula"
        }
        else{
            //try to march by name
             naturalProducts = this.uniqueNaturalProductRepository.findByName(query)

            if(naturalProducts == null || naturalProducts.isEmpty()){
                naturalProducts = this.uniqueNaturalProductRepository.fuzzyNameSearch(query)
            }
             determinedInputType = "name"
        }




        return mapOf(
                "originalQuery" to query,
                "determinedInputType" to determinedInputType,
                "naturalProducts" to naturalProducts
        )
    }
}